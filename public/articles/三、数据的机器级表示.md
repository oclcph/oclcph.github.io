---
title: 数据的机器级表示与校验码
abstract: 计组第三、四章笔记
category: 计算机组成原理
---

# 三、数据的机器级表示

**编码：**用少量简单的**基本符号**对复杂多样的信息进行一定**规律**的组合

## 整数的二进制数表示

（有符号整数）原码、反码、移码、补码

### 补码

**表示：**与无符号整数相比，如果一共有k位

1. 000...000~011...111：表示的值不变
2. 100...000\~111...111：表示的值由$2^{k-1}\text{~} 2^k-1$变为$-2^{k-1}\text{~}-1$

> 值为原来的无符号数对应的值减去$2^k$（**取反加1**）

$-2^{k-1} \leq X \leq 2^{n-1}-1$

$X=-X_k\times 2^{k-1}+\sum_{i=1}^{k-1}2^{i-1}X_i$

### 原码、反码、移码

## 浮点数的二进制数表示

**基础概念：**科学计数法$\pm S\times B^E$

1. $\pm$：正负号
2. $S$：尾数/有效值
3. $B$：底/基，对所有数都是相同的，不需要存储
4. $E$：阶码/指数

### 规格化数

形式为：$\pm 1.bbb...b\times 2^E$

1. 符号总是位于字的第1位
2. 尾数S的第一位规定为1，不需要存储（默认省略）
3. 阶码E真实值加**偏移量**，再存入阶码字段中（移码）
4. 底默认为2

> 单精度浮点数（32位）中指数位为8位，偏移量是127；双精度浮点数（64位）中指数位为11位，偏移量是$2^{11-1} - 1 = 1023$

**范围**

1. $-(2-2^{-23})\times 2^{128}$~$-2^{-127}$的负数
2. $2^{-127}$~$(2-2^{-23})\times 2^{128}$的正数

> 可以想想为什么
>
> **阶码不能全为0，因此最小正规格化数为$2^{-126}$**

![image-20240920153143201](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920153143201.png)

**变化**

1. 增加E位数：扩大表示范围，降低表示精度
2. 增加S位数：提高精度，减少范围
3. 采用更大的底B：更大范围

### 非规格化数

处理下溢情况，即增大E位数。

**舍入：**就近舍入、朝正/负无穷舍入、朝0舍入

## 二进制编码的十进制数表示

### 自然BCD码（NBCD码）

把0-9用0000-1001表示

例如2039表示为0 0010 0000 0011 1001

-1365表示为1 0001 0010 0110 0101

# 四、数据校验码

**差错**

数据再计算机内部进行计算、存取、传送过程中由于元器件故障或噪音干扰等原因出现差错

以存储为例：

1. 硬故障：永久性故障，存储单元不能可靠存储数据，成为固定的1/0故障。制造缺陷、旧损
2. 软故障：随机非破坏性时间，电源问题或$\alpha$粒子

## 纠错

![image-20240920160519915](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920160519915.png)

1. 使用函数$f$在$M$位数据$D$上生成$K$位校验码$C$
2. $D、C$过存储器变成$D_1、C_1$
3. 使用函数$f$在$M$位数据$D_1$上生成$K$位校验码$C_2$
4. 比较$C_1、C_2$，若一样则使用$D_1$
   1. 检测到差错且可以矫正，则矫正数据
   2. 检测到差错不可矫正则进行报告

### 奇偶校验码

在原数据中增加1位校验码。

**奇校验：**添加后数据中1的数量为奇数

**偶校验：**添加后数据中1的数量为偶数

对比$C_1、C_2$，若不相同，则证明数据中出错位数为奇数，若相同则证明数据正确或出错位数为偶数

### 海明码

1. M位数据分成K组
2. 对D每组生成1位校验码，合并得到K位校验码C
3. 对D'每组生成1位校验码，合并得到K位校验码C''
4. 将C'和C''按位异或，生成K位**故障字**

**校验码长度**

对于最多出现1位错的情况，有可能无错，有可能M位数据有错，有可能K位校验码有错

而K位校验码一共能表示$2^K$种出错情况

则K和M应满足$2^K\geq 1+M+K$

**故障字规则**

1. 全部是0：无错
2. 有且仅有1位是1：错误发生在校验码中的某一位，不需要纠正
3. 多位是1：错误发生在数据中的某一位，需要将D'中对应数据位取反纠正

**以8位数据进行单个位的纠错为例**

假定8位数据$M=M_1M_2M_3M_4M_5M_6M_7M_8$，4位校验位$P=P_1P_2P_3P_4$.

1. 故障字为0000时表示无错
2. 故障字为0001、0010、0100、1000时分别表示由1位校验码出错，则可以把这四位校验码放在对应的位置上
3. 剩余故障字表示数据为出错

因此码字排列为$M_8M_7M_6M_5P_4M_4M_3M_2P_3M_1P_2P_1$

若故障字和出错情况如下图所示，则可以有分组 第三位既属于第一组又属于第二组......

![image-20240920172528083](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920172528083.png)

![image-20240920172719131](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920172719131.png)

![image-20240920174007655](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920174007655.png)![image-20240920174015908](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920174015908.png)

### 循环冗余校验

1. 将M位数据左移K位（右侧补0），并用K+1位**生成多项式**除它（**模2**）
2. 采用K位余数作为校验码
3. 把校验码放在数据后面（不含0），一同存储或传输

**纠错：**若M+K位内容可以被多项式除尽，则无错，否则有错
