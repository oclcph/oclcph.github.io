---
title: 整数运算与浮点数运算
abstract: 计组第五、六章笔记
category: 计算机组成原理
---

# 五、整数运算

**算术逻辑单元（ALU）**

![image-20240920190836099](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920190836099.png)

## 全加器

第i位加法:

$$
S_i=X_i\oplus Y_i\oplus C_{i-1}
$$

$$
C_i=X_iC_{i-1}+Y_iC_{i-1}+X_iY_i
$$

其中$C_i$为第i位的进位。

![image-20240920192930482](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920192930482.png)

### 串行进位加法器

![image-20240920193801024](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920193801024.png)

延迟：

1. $C_n$：2nty
2. $S_n$：（2n+1）ty

> $S_n$延迟：n>2时，2(n-1)+3=2n+1

### 全先行进位加法器（CLA）

定义两个辅助函数

$P_i=X_i+Y_i$，$G_i=X_iY_i$

则根据上述递推可以得到$C_i=G_i+P_iG_{i-1}+P_iP_{i-1}G_{i-2}+...+P_iP_{i-1}P_{i-2}...P_iC_0$

即$C_i$只与$G_i、P_i、C_0$有关

![image-20240920200917465](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240920200917465.png)

延迟计算：由$X_i、Y_i$生成$G_i、P_i$需要1级门延迟，$G_i、P_i、C_0$生成$C_i$需要2级门延迟，生成$S_i$需要3级门延迟

> 线路太过复杂

### 部分先行进位加法器

采用多个CLA并串联

## 乘法

### 无符号数

对于$X\times Y：$

1. 按位求积得部分积
2. 若$Y_i=0$，则直接将部分积右移；若$Y_i=1$，则将部分积相加后右移

![image-20240928202139583](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240928202139583.png)

### 有符号数

**布斯算法**：$P_{i+1}=2^{-1}\times(P_i+X\times(Y_i-Y_{i+1}))$

1. 增加$Y_0=0$
2. 根据$Y_{i+1}-Y_i$，决定是否增加$+X,-X,0$
3. 右移部分积

![image-20240928210142070](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240928210142070.png)

## 除法

若被除数为0，除数不为0，则商为0；

若被除数不为0，除数为0，则发生异常

若被除数、除数都不为0，则进行运算

### 无符号数

![image-20240928211103464](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240928211103464.png)

1. 被除数左移左侧补n位0并存在余数和商寄存器中
2. 被除数左移1位
3. 被除数减除数，若够减则减去并商1，若不够减则不减并商0
4. 重复2-3直到余数位数和除数相同

### 有符号数

**步骤：**

1. 被除数前扩展n位并存储在余数寄存器和商寄存器中
2. 余数、商左移，判断是否“够减”
   1. 够减则做减法或加法，商1
   2. 不够减则商0
3. **如果除数和被除数不同号，则将商替换为相反数**
4. 余数在余数寄存器中

**判断是否“够减”：**（恢复余数算法）

1. 先做减法/加法，得到余数
2. 判断余数和被除数是否同号
   1. 同号则“够减”
   2. 不同号则“不够减”，需要加法/减法恢复余数

![image-20240928213120818](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240928213120818.png)

**判断是否够减：**（不恢复余数）

1. 被除数前扩展n位，存储在余数寄存器和商寄存器中
2. 如果余数和除数符号相同，则作减法，否则做加法
3. 如果余数和除数符号相同则商1，否则商0
4. 重复2-3
5. **左移商**
   1. 如果商为负，商加1
6. 余数和被除数符号不同，需要修正余数
   1. 如果被除数与除数符号相同，则余数加除数，否则减除数

![image-20240928214810048](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240928214810048.png)

# 六、浮点数加减

## 加减

![image-20240926111303918](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240926111303918.png)

**步骤：**

1. 检查是否是0
2. 对阶，比较阶码，并由此对齐尾数**（对齐尾数时左边先补一个1，其余补0）**
3. 加/减尾数
4. 规格化结果

**原则：**若两个操作数有相同的符号，那么做加法，否则做减法

1. 做加法时直接相加，如果最高位有进位则溢出，符号与被加数相同
2. 做减法时加第二个操作数的补数，如果最高位有进位则正确，符号与被减数相同；否则计算补码，符号与被减数相反

**例1：**$0.8125 = 0.1101=1.101\times 2^{-1}, 0.625=0.101=1.01\times 2^{-1}$，阶码相同

$0.8125+0.625=0.1101+0.1010=1.0111$，如果寄存器只能存4位，那么会有溢出，结果为$0.0111=0.4375$

$0.8125-0.625=0.1101+0.0110=1.0011$，如果寄存器只能存4位，那么结果正确，符号与被减数相同，$0.1875$

$0.625-0.8125=0.1010+0.0011=0.1101$，如果寄存器只能存4位，那么没有进位，结果需要计算补码$0.0011$，符号与被减数相反，结果是-0.1875

**例2：**$0.5=0.1=1.0*2^{-1}=0\ 01111110\ 000...00$，$0.4375=0.0111=1.11*2^{-2}=0\ 01111101\ 110...00$

**考虑0.5-（-0.4375）=0.5+0.4375**

阶码不同，要先对阶：$01111110-01111101=00000001$

说明0.4375阶码小，尾数需要右移1位，左边补一个1，$111...00+000...00=111...00$

结果为$0\ 01111110\ 111...00$，即0.9375

**考虑0.5+（-0.4375）=0.5-（+0.4375）**

阶码不同先对阶，0.4375尾数右移1位，左边补一个1，$000...00-111...00=001...00$

结果符号和被减数相同，为$0\ 01111110\ 001...00$

规格化结果，由于尾数相减的时候借了1，因此上述结果的尾数为$0.001\times 2^{-1}=1.0\times 2^{-4}$，规格化结果为$0\ 01111011\ 000...00$，为0.0625

## 乘法

![image-20240926150730556](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240926150730556.png)

1. 判断是否有0，有0则返回0
2. 阶码相加后减去一个偏移量
3. 尾数相乘
4. 规格化，舍入处理

**例：**$0.5\times 0.4375$

1. 阶码：$01111110+01111101-01111111=01111100$
2. 尾数：0.5尾数为0，那么相乘后尾数为0.4375的尾数
3. 结果为$0\ 01111100\ 110...00$

## 除法

1. 若除数为0，则报错或设置为无穷大
2. 若被除数为0，则结果为0
3. 阶码相减后加上一个偏移量
4. 尾数相除
5. 规格化、舍入处理

![image-20240926151423523](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20240926151423523.png)

**例：**0.4375/0.5

1. 阶码：$01111101-01111110+01111111=01111110$
2. 尾数：0.5尾数为0，因此尾数即为0.4375的尾数
3. 结果为$0\ 01111110\ 110...00$

## 精度考虑

**保护位：**用0填充，用于扩充有效值的右端

**舍入：**对有效值操作的结果通常保存在更长的寄存器中，当结果转回浮点格式时会去掉多余的位

**例：**考虑一个16位的浮点数，1位符号，9位尾数，6位价值，偏移量31

$-7.48=-(+7.48)=-(111+0.0111101011...)=-1.110111101011\times2^{2}=1\ 100001\ 110111101$

同理，$652.13=0\ 101000\ 010001100$

对于652.13+（-7.48），先对阶，-7.48尾数右移7位，变成0000111 0111101

1. 如果不考虑保护位，那么即010001100-000000111=010000101，答案是0 101000 010000101=645.0
2. 如果考虑保护位，那么即010001100 000000-0000111 011110=010000100 100010，
   1. 就近/朝正无穷舍入即为645.0
   2. 朝负无穷/朝0舍入即为644.0
