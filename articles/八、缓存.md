---
title: 缓存（cache）
abstract: 计组第八章笔记
category: 计算机组成原理
---

# 八、缓存（Cache）

CPU速度远超主存，因此在CPU和主存之间增加一块小而快的cache

**工作流程**

1. 检查：CPU先检查目标字是否在cache中
2. 若命中，则直接从cache中传送给cpu
3. 若未命中，则将主存中包含这个字固定大小的块读入cache，再传送给cpu

## 问题

**==判断是否命中==：**CPU通过**位置**对主存内容进行寻址，而cache中通过**标记**来标识其内容在主存中的对应位置

1. 解析主存地址，找出相应的Cache行
2. 对比该Cache行的标记是否于主存地址标记相同
   1. 若相同则根据块偏移取出
   2. 若不同则为命中

**局部性原理**：处理器频繁访问主存中相同位置或相邻存储位置的现象

1. 时间局部性：较短时间里重复访问特定信息
2. 空间局部性：较短时间里多次访问相邻存储位置的数据

**==传送块而非字==：**空间局部性

**==传送到Cache==：**时间局部性

**平均访问时间：**若p为命中率，$T_C$为cache访问时间，$T_M$为主存访问时间，那么平均访问时间为$T_A=p\times T_C+(1-p)\times (T_C+T_M)=T_C+(1-p)\times T_M$

> 命中率越大，$T_C$越小，效果越好

## 构成

![image-20241104202336357](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20241104202336357.png)

Cache系统包括Cache控制器（虚框内）、Cache存储体

1. 标记存储体，由SRAM构成，存放主存的组号
2. 数据存储体，由SRAM构成，存放组内对应块的主存信息

## 设计要素

1. Cache容量：增大命中率，但也会增加访问时间
2. 映射功能：实现主存块到cache行的映射
   1. 直接映射：将主存中的每个块映射到一个固定可用的Cache行
      1. 若i是Cache行号，j是主存块号，C是Cache行数，则i=j mod C
      2. 标记：地址中最高的n位。**主存地址=标记+Cache行号+块内地址**，用来区分映射到同一行的不同块
      3. 缺点：抖动，两个映射到同一行的块可能会被不断交换
   2. 关联映射：主存块可以装入Cache任意一行
      1. 标记：$n=log_2M$，其中M是块数。**主存地址=块号/标记+块内地址**
      2. 缺点：实现复杂，并且检查时需要访问每一行来进行搜索、对比块号
   3. 组关联映射：Cache分为若干组，每一组包含相同数量的行，每个块被映射到固定组的任意一行
      1. 若S为组数，M为块数，则$n=log_2M-log_2S$，**主存地址=标记+Cache组号+块内地址**
   4. ==关联度==：一个主存块映射到Cache中可能存放的位置个数
      1. 关联度越低，命中率越低，判断是否命中时间越短，标记所占额外空间开销越小
3. 替换算法：将新数据块装入cache替换原有数据块时
   1. 直接映射不考虑
   2. （组）关联映射中需要，硬件实现
   3. 最近最少使用算法，替换掉在cache中**最长时间未被访问**的块
      1. 对于2路组关联映射，每行设置一个USE位。当同一组中的某行被访问时USE位置1，同时另一行置0，替换掉USE位为0的块
   4. 先进先出算法，替换掉Cache中**停留时间最长**的块
      1. 时间片轮转法/环形缓冲技术。每行包含标识位，替换标识位为0的行，某行被替换时将其标识位置1，下一行置0
   5. 最不经常使用算法，替换掉Cache中访问次数最少的数据块
      1. 每一行设置计数器
   6. 随即替换算法，随机替换
4. 写策略：主存和Cache一致，当某行Cache被替换时需要判断其中内容是否被修改。若被修改则需要将修改后的数据块写回主存中对应位置
   1. 写直达，所有些操作同时对Cache和主存进行
   2. 写回法，用一个dirty bit或使用位来标记该处内容是否被修改
5. 行大小：随着每一行逐渐变大，Cache命中率会先增加后减小
   1. 先会有更多数据作为一个块装入Cache中，空间局部性
   2. 行较大后空间局部性效果减小，被使用的可能性减小，同时行数变小，块被频繁替换
6. Cache数目
   1. 一级 v.s. 多级
   2. 统一 v.s. 分立
